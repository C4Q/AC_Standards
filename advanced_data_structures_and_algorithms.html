<html>
<head>

  <title>Core Standards: Data Structures and Algorithms</title>

  <link rel="stylesheet" type="text/css" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

</head>
<body>
  <div class="container">
  <div class="container-inner">
    <div class="left-sidebar">
      <div class="home-anchor">
        <h3><a id="home" href="index.html">Pursuit Core Standards</a></h3>
      </div>
      <div class="navigation-links">
        <div class="navigation-link-item"><a href="language_fundamentals.html">Language Fundamentals</a></div>
        <div class="navigation-link-item"><a href="engineering_foundations.html">Engineering Foundations</a></div>
        <div class="navigation-link-item"><a href="advanced_data_structures_and_algorithms.html">Data Structures and Algorithms</a></div>
        <div class="navigation-link-item"><a href="ps.html">Professional Skills</a></div>
        <div class="navigation-link-item"><a href="if.html">Industry Fluency</a></div>
        <div class="navigation-link-item"><a href="web_core.html">Full Stack Web</a></div>
        <div class="navigation-link-item"><a href="ios_core.html">iOS</a></div>
      </div>
    </div>
    <div class="content">
<h1>Data Structures and Algorithms [DSA]</h1>

<h2>Introduction</h2>
<p>Data Structures & Algorithms (DSA) are the building blocks that allow programmers to code and think at a higher level. Data structures are unique ways of organising and collecting data so that we can perform operations in an effective way. Algorithms are a set of instructions that solve hard problems in an efficient manner. Understanding DSA is critical for entry level interviews. DSA is usually technology agnostic so it instills a strong computer science mindset.</p>

<p>## Goals

- Students should be able to build and apply important Data Structures used in the real world.
- Students should be able to design and apply correct Algorithms for programming problems.
- Students should get a basic sense of "abstract data structures" and how the flow of data occurs in applications.
- Students should begin to understand efficiency of code and learn to code beyond the "brute force" route.
- Students should be able to problem solve at a high level during whiteboarding interviews.
</p>


<h2>Abstract Data Structures</h2>
<p><strong>DSA.1</strong> Understand that native data types and how you associate them is the foundation of all abstract data Structures.</p>

<p><strong>DSA.1.a</strong> Show examples of association between data, example: linking lists and graphs</p>

<p><strong>DSA.1.b</strong> Singly Linked List: Understand how to build a Node class and the relationship between nodes, implement SLL class with Head only, implement: push(), pop(), find(), and understand the run time for each method</p>

<p><strong>DSA.1.c</strong> Doubly Linked List: Implement DLL class with Head and Tail pointers, implement: push(), pop(), find(), removeAt(), understand the run time for each method.</p>

<p><strong>DSA.1.d</strong> Hash Tables: Understand dictionaries, key and value mapping, real world use cases, and common methods and run times. Understand the reason for a Hash Method, how to get O(1) insert and find, collision, and best case vs worst case runtimes.</p>

<p><strong>DSA.1.e</strong> Stacks: Understand LIFO and real world use cases, implement: push(), pop(), isEmpty(), and understand the run time for each method.</p>

<p><strong>DSA.1.f</strong> Queues: Understand FIFO and real world use cases, implement: Enqueue(), Dequeue(), isEmpty(), and understand the run time for each method.</p>
<br>


<h2>Big(O) Notation</h2>
<p><strong>DSA.2</strong> Know that big(O) notation is used to describe the worst case space or time required to execute an algorithm.

  <p>Know that O(1) describes and algorithm that will require the same time/space no matter the size of the data set it operates on. Explain why a O(1) algorithm's graph is flat line.</p>

  <p>Know that O(n) describes an algorithm that will increase space/time requirements linearly in proportion to the size of the data set it operates on. Explain why an O(n) algorithm's graph is a straight diagnal line, going up from left to right.</p>

  <p>Know that O(n<sup>2</sup>) describes an algorithm that will increase space/time requirements in proportion to the square of the size of the data set. Understand that usually refers to an iteration nested within an interation and that additional nestings will lead to O(n<sup>3</sup>), O(n<sup>4</sup>), etc. Know that O(n<sup>2</sup>) will produce a parabolic graph.</p>

  <p>Know that O(2<sup>n</sup>) describes an algorithm that will double in space/time requirements for every increase in the size of the data set. Know that the graph for O(2<sup>n</sup>) is exponential, starting off shallow and increasing sharply until it appears vertical.</p>

  <p>Know that O(log n) describes an algorithm (often binary search) where that

  <p>Know the the order of most effient(requires the least space/time) to least efficient (requires the most space/time) is O(1), O(n), O(n<sup>2</sup>), O(2<sup>n</sup>)</p>

  Runtime Complexity: Understand the difference between O(1) and O(n). Understand the relationship between data collection size and run time. Show and explain big O graph</p>


<h2>Recursion</h2>

<details>
  <summary>Recursion Basics</summary>
  <ul>
    <li>Student should implement Factorial function</li>
    <li>Student should implement Fibonnaci</li>
    <li>Student should understand call stack and returns</li>
  </ul>
</details>

<details>
  <summary>Divide and Conquer</summary>
  <ul>
    <li>Student should try brute force search on an Array</li>
    <li>Student should understand worst case for brute force search</li>
    <li>Student should understand binary search</li>
    <li>Student should understand worst case for binary search</li>
    <li>Student should implement binary search</li>
  </ul>
</details>

<h2>Sorting Algorthims</h2>


  <p>Sorting Premise and Bubble Sort</p>
  <ul>
    <li>Student should understand why we sort and why it's useful</li>
    <li>Real world examples of sorting</li>
    <li>Compare different sorting algorithms and runtimes</li>
    <li>Implement Bubble Sort</li>
  </ul>


<details>
  <summary>Quick Sort</summary>
  <ul>
    <li>Run time</li>
    <li>Implementation</li>
  </ul>
</details>

<details>
  <summary>Merge Sort</summary>
  <ul>
    <li>Run time</li>
    <li>Implementation</li>
  </ul>
</details>

### 8) Binary Search Tree

<details>
  <summary>Trees</summary>
  <ul>
    <li>Student should understand abstraction of a tree data type</li>
    <li>Should be able to easily implement using Nodes</li>
    <li>Understand use cases</li>
  </ul>
</details>

<details>
  <summary>Binary Search Tree</summary>
  <ul>
    <li>Student should understand rules of a BST</li>
    <li>Student should understand use case of a BST</li>
    <li>Student should implement insert() and find()</li>
    <li>Min() and Max()</li>
  </ul>
</details>

### 9) Search Algorithms

<details>
  <summary>Depth First / Breadth First</summary>
  <ul>
    <li>Implement Depth First Search</li>
    <li>Implement Breadth First Search</li>
  </ul>
</details>

### 10) Graphs & Dijkstra’s Algorithm

<details>
  <summary>Graphs</summary>
  <ul>
    <li>Student should understand abstraction of a graph data type</li>
    <li>Should be able to easily implement using Nodes</li>
    <li>Understand use cases</li>
  </ul>
</details>

<details>
  <summary>Dijkstra’s Algorithm</summary>
  <ul>
    <li>Student should understand concept of shortest path algorithm</li>
    <li>Understand vertex</li>
    <li>Understand use cases, example: Google Maps, MTA Route to Destination</li>
    <li>Implement Dijkstra's Algorithm</li>
  </ul>
</details>
    </div>
  </div>
  </div>
</body>
</html>
